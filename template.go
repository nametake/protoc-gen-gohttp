package main

const codeTemplate = `// Code generated by protoc-gen-gohttp. DO NOT EDIT.
// source: {{ .Name }}

package {{ .GoPkg }}

import (
	"bytes"
	"context"
	{{ if .IsImportBase64 -}}
	"encoding/base64"
	{{ end -}}
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"mime"
	"net/http"
	{{ if .IsImportReflect -}}
	"reflect"
	{{ end -}}
	{{ if .IsImportStrConv -}}
	"strconv"
	{{ end -}}
	"strings"

	"github.com/golang/protobuf/jsonpb"
	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)
{{ range $i, $service := .Services }}
// {{ $service.Name }}HTTPConverter has a function to convert {{ $service.Name }}Server interface to http.HandlerFunc.
type {{ $service.Name }}HTTPConverter struct {
	srv {{ $service.Name }}Server
}

// New{{ $service.Name }}HTTPConverter returns {{ $service.Name }}HTTPConverter.
func New{{ $service.Name }}HTTPConverter(srv {{ $service.Name }}Server) *{{ $service.Name }}HTTPConverter {
	return &{{ $service.Name }}HTTPConverter{
		srv: srv,
	}
}
{{ range $j, $method := $service.Methods }}
// {{ $method.Name }} returns {{ $service.Name }}Server interface's {{ $method.Name }} converted to http.HandlerFunc.
{{ if ne $method.Comment "" -}}
//
// {{ $method.Comment }}
{{ end -}}
func (h *{{ $service.Name }}HTTPConverter) {{ $method.Name }}(cb func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) http.HandlerFunc {
	if cb == nil {
		cb = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					if err := json.NewEncoder(w).Encode(p); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		arg := &{{ $method.Arg }}{}
		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				cb(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					cb(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := jsonpb.Unmarshal(bytes.NewBuffer(body), arg); err != nil {
					cb(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				cb(ctx, w, r, nil, nil, err)
				return
			}
		}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/{{ $.Pkg }}.{{ $service.Name }}/{{ $method.Name }}",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.{{ $method.Name }}(c, req.(* {{ $method.Arg }}))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			cb(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*{{ $method.Ret }})
		if !ok {
			cb(ctx, w, r, arg, nil, fmt.Errorf("/{{ $.Pkg }}.{{ $service.Name }}/{{ $method.Name }}: interceptors have not return {{ $method.Ret }}"))
			return
		}

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == ""{
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				cb(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				cb(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			m := jsonpb.Marshaler{
				EnumsAsInts:  true,
				EmitDefaults: true,
			}
			if err := m.Marshal(w, ret); err != nil {
				cb(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			cb(ctx, w, r, arg, ret, err)
			return
		}
		cb(ctx, w, r, arg, ret, nil)
	})
}

// {{ $method.Name }}WithName returns Service name, Method name and {{ $service.Name }}Server interface's {{ $method.Name }} converted to http.HandlerFunc.
{{ if ne $method.Comment "" -}}
//
// {{ $method.Comment }}
{{ end -}}
func (h *{{ $service.Name }}HTTPConverter) {{ $method.Name }}WithName(cb func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	return "{{ $service.Name }}", "{{ $method.Name }}", h.{{ $method.Name }}(cb, interceptors...)
}

{{ if $method.HTTPRule -}}
func (h *{{ $service.Name }}HTTPConverter) {{ $method.Name }}HTTPRule(cb func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error), interceptors ...grpc.UnaryServerInterceptor) (string, string, http.HandlerFunc) {
	if cb == nil {
		cb = func(ctx context.Context, w http.ResponseWriter, r *http.Request, arg, ret proto.Message, err error) {
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				p := status.New(codes.Unknown, err.Error()).Proto()
				switch contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type")); contentType {
				case "application/protobuf", "application/x-protobuf":
					buf, err := proto.Marshal(p)
					if err != nil {
						return
					}
					if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
						return
					}
				case "application/json":
					if err := json.NewEncoder(w).Encode(p); err != nil {
						return
					}
				default:
				}
			}
		}
	}
	return {{ $method.HTTPRule.GetMethod }}, "{{ $method.HTTPRule.Pattern }}", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		arg := &{{ $method.Arg }}{}
		contentType, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))
		{{ if $method.GetQueryParams -}}
		if r.Method == http.MethodGet {
		{{ range $k, $queryParam := $method.GetQueryParams -}}
			{{ template "queryString" $queryParam -}}
		{{ end -}}
		}
		{{ else -}}
		if r.Method != http.MethodGet {
			body, err := ioutil.ReadAll(r.Body)
			if err != nil {
				cb(ctx, w, r, nil, nil, err)
				return
			}

			switch contentType {
			case "application/protobuf", "application/x-protobuf":
				if err := proto.Unmarshal(body, arg); err != nil {
					cb(ctx, w, r, nil, nil, err)
					return
				}
			case "application/json":
				if err := jsonpb.Unmarshal(bytes.NewBuffer(body), arg); err != nil {
					cb(ctx, w, r, nil, nil, err)
					return
				}
			default:
				w.WriteHeader(http.StatusUnsupportedMediaType)
				_, err := fmt.Fprintf(w, "Unsupported Content-Type: %s", contentType)
				cb(ctx, w, r, nil, nil, err)
				return
			}
		}
		{{ end }}

		{{ if $method.HTTPRule.Variables -}}
		p := strings.Split(r.URL.Path, "/")
		{{ range $j, $variable := $method.HTTPRule.Variables -}}
		{{ if $method.IsCreateInstance $variable.GetPath -}}
		{{ range $k, $p := $variable.GetPaths -}}
		reflect.ValueOf(&arg.{{ $p }}).Elem().Set(reflect.ValueOf(reflect.New(reflect.TypeOf(arg.{{ $p }}).Elem()).Interface()))
		{{ end -}}
		{{ end -}}
		arg.{{ $variable.GetPath }} = p[{{ $variable.Index }}]
		{{ end -}}
		{{ end }}

		n := len(interceptors)
		chained := func(ctx context.Context, arg interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
			chainer := func(currentInter grpc.UnaryServerInterceptor, currentHandler grpc.UnaryHandler) grpc.UnaryHandler {
				return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
					return currentInter(currentCtx, currentReq, info, currentHandler)
				}
			}

			chainedHandler := handler
			for i := n - 1; i >= 0; i-- {
				chainedHandler = chainer(interceptors[i], chainedHandler)
			}
			return chainedHandler(ctx, arg)
		}

		info := &grpc.UnaryServerInfo{
			Server:     h.srv,
			FullMethod: "/{{ $.Pkg }}.{{ $service.Name }}/{{ $method.Name }}",
		}

		handler := func(c context.Context, req interface{}) (interface{}, error) {
			return h.srv.{{ $method.Name }}(c, req.(* {{ $method.Arg }}))
		}

		iret, err := chained(ctx, arg, info, handler)
		if err != nil {
			cb(ctx, w, r, arg, nil, err)
			return
		}

		ret, ok := iret.(*{{ $method.Ret }})
		if !ok {
			cb(ctx, w, r, arg, nil, fmt.Errorf("/{{ $.Pkg }}.{{ $service.Name }}/{{ $method.Name }}: interceptors have not return {{ $method.Ret }}"))
			return
		}

		accepts := strings.Split(r.Header.Get("Accept"), ",")
		accept := accepts[0]
		if accept == "*/*" || accept == ""{
			if contentType != "" {
				accept = contentType
			} else {
				accept = "application/json"
			}
		}

		w.Header().Set("Content-Type", accept)

		switch accept {
		case "application/protobuf", "application/x-protobuf":
			buf, err := proto.Marshal(ret)
			if err != nil {
				cb(ctx, w, r, arg, ret, err)
				return
			}
			if _, err := io.Copy(w, bytes.NewBuffer(buf)); err != nil {
				cb(ctx, w, r, arg, ret, err)
				return
			}
		case "application/json":
			m := jsonpb.Marshaler{
				EnumsAsInts:  true,
				EmitDefaults: true,
			}
			if err := m.Marshal(w, ret); err != nil {
				cb(ctx, w, r, arg, ret, err)
				return
			}
		default:
			w.WriteHeader(http.StatusUnsupportedMediaType)
			_, err := fmt.Fprintf(w, "Unsupported Accept: %s", accept)
			cb(ctx, w, r, arg, ret, err)
			return
		}
		cb(ctx, w, r, arg, ret, nil)
	})
}
{{ end -}}
{{ end -}}
{{ end -}}
` + queryParamsTemplate

const queryParamsTemplate = `{{ define "queryString" -}}
{{ if eq .QueryType "DOUBLE" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	d, err := strconv.ParseFloat(v, 64)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = d
}
{{ else if eq .QueryType "FLOAT" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	f, err := strconv.ParseFloat(v, 32)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = float32(f)
}
{{ else if eq .QueryType "INT32" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	i32, err := strconv.ParseInt(v, 10, 32)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = int32(i32)
}
{{ else if eq .QueryType "INT64" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	i64, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = i64
}
{{ else if eq .QueryType "UINT32" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	ui32, err := strconv.ParseUint(v, 10, 32)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = uint32(ui32)
}
{{ else if eq .QueryType "UINT64" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	ui64, err := strconv.ParseUint(v, 10, 64)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = uint64(ui64)
}
{{ else if eq .QueryType "FIXED32" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	f32, err := strconv.ParseUint(v, 10, 32)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = uint32(f32)
}
{{ else if eq .QueryType "FIXED64" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	f64, err := strconv.ParseUint(v, 10, 64)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = uint64(f64)
}
{{ else if eq .QueryType "SFIXED32" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	sf32, err := strconv.ParseInt(v, 10, 32)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = int32(sf32)
}
{{ else if eq .QueryType "SFIXED64" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	sf64, err := strconv.ParseInt(v, 10, 64)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = int64(sf64)
}
{{ else if eq .QueryType "BOOL" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	b, err := strconv.ParseBool(v)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = b
}
{{ else if eq .QueryType "STRING" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	arg.{{ .GetPath }} = v
}
{{ else if eq .QueryType "BYTES" -}}
if v := r.URL.Query().Get("{{ .Key }}"); v != "" {
	b, err := base64.StdEncoding.DecodeString(v)
	if err != nil {
		cb(ctx, w, r, nil, nil, err)
		return
	}
	arg.{{ .GetPath }} = b
}
{{ else if eq .QueryType "REPEATED_DOUBLE" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]float64, 0, len(repeated))
	for _, v := range repeated {
		d, err := strconv.ParseFloat(v, 64)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, d)
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_FLOAT" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]float32, 0, len(repeated))
	for _, v := range repeated {
		f, err := strconv.ParseFloat(v, 32)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, float32(f))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_INT32" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]int32, 0, len(repeated))
	for _, v := range repeated {
		i32, err := strconv.ParseFloat(v, 32)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, int32(i32))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_INT64" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]int64, 0, len(repeated))
	for _, v := range repeated {
		i64, err := strconv.ParseFloat(v, 64)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, int64(i64))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_UINT32" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]uint32, 0, len(repeated))
	for _, v := range repeated {
		ui32, err := strconv.ParseFloat(v, 32)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, uint32(ui32))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_UINT64" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]uint64, 0, len(repeated))
	for _, v := range repeated {
		ui64, err := strconv.ParseFloat(v, 64)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, uint64(ui64))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_FIXED32" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]uint32, 0, len(repeated))
	for _, v := range repeated {
		f32, err := strconv.ParseFloat(v, 32)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, uint32(f32))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_FIXED64" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]uint64, 0, len(repeated))
	for _, v := range repeated {
		f64, err := strconv.ParseFloat(v, 64)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, uint64(f64))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_SFIXED32" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]int32, 0, len(repeated))
	for _, v := range repeated {
		sf32, err := strconv.ParseFloat(v, 32)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, int32(sf32))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_SFIXED64" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]int64, 0, len(repeated))
	for _, v := range repeated {
		sf64, err := strconv.ParseFloat(v, 64)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, int64(sf64))
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_BOOL" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]bool, 0, len(repeated))
	for _, v := range repeated {
		b, err := strconv.ParseBool(v)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, b)
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_STRING" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([]string, 0, len(repeated))
	for _, v := range repeated {
		arr = append(arr, v)
	}
	arg.{{ .GetPath }} = arr
}
{{ else if eq .QueryType "REPEATED_BYTES" -}}
if repeated := r.URL.Query()["{{ .Key }}"]; len(repeated) != 0 {
	arr := make([][]byte, 0, len(repeated))
	for _, v := range repeated {
		b, err := base64.StdEncoding.DecodeString(v)
		if err != nil {
			cb(ctx, w, r, nil, nil, err)
			return
		}
		arr = append(arr, b)
	}
	arg.{{ .GetPath }} = arr
}
{{ end -}}
{{ end -}}`
